<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta content="manixaist.github.io" property="og:site_name">

  <meta content="Cross Platform Game - 06" property="og:title">


  <meta content="article" property="og:type">


  <meta content="<h1>Developer Journal</h1><h4>Github pages for coding projects:</h4><p/><h4>A collection of my hobbyist projects.</h4><p/><a href='http://xkcd.com/1724/'><img src='http://imgs.xkcd.com/comics/proofs.png'/></a" property="og:description">


  <meta content="http://manixaist.github.io/coding/game/xplat/2016/09/27/xplat-pmc-06.html" property="og:url">


  <meta content="2016-09-27T10:47:00-07:00" property="article:published_time">
  <meta content="http://manixaist.github.io/about/" property="article:author">


  <meta property="og:image" content="">


  
  <meta content="coding" property="article:section">
  


  

  <title>Cross Platform Game - 06</title>
  <meta name="description" content="Remaining Enemy Ghosts and AII also included player lives last time, but we’re skipping that for now as it makes the AI easier to see if the player is invinc...">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/css/main.css">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

  <link href='https://fonts.googleapis.com/css?family=PT+Sans' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Fira+Mono' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,200,300,500,600,700,900' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Gentium+Basic:400,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Alegreya:400,400italic,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Lora:400,400italic,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Fira+Sans:400,300,500,700' rel='stylesheet' type='text/css'>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-hQpvDQiCJaD2H465dQfA717v7lu5qHWtDbWNPvaTJ0ID5xnPUlVXnKzq7b8YUkbN" crossorigin="anonymous">
  <link rel="canonical" href="http://manixaist.github.io/coding/game/xplat/2016/09/27/xplat-pmc-06.html">
  <link rel="alternate" type="application/rss+xml" title="manixaist.github.io" href="http://manixaist.github.io/feed.xml">
</head>


  <body>
<section>
<nav class="navbar navbar-default navbar-fixed-top">

  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">manixaist.github.io</a>
    </div>


    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        
        

        
        

        
        

        


      </ul>

    <!--  <ul class="nav navbar-nav navbar-right">
        <li><a href="#">Know More!</a></li>

      </ul>-->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
</section>

<section>
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="jumbotron">
    <div class="container">
      <h1 class="post-title-main" itemprop="name headline">Cross Platform Game - 06</h1>
      <p class="post-meta"><time datetime="2016-09-27T10:47:00-07:00" itemprop="datePublished">Sep 27, 2016</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">manixaist</span></span></p>
      
    </div>

</div>


  <div class="post-content container" itemprop="articleBody">
    <h1 id="remaining-enemy-ghosts-and-ai">Remaining Enemy Ghosts and AI</h1>
<p>I also included player lives last time, but we’re skipping that for now as it makes the AI easier to see if the player is invincible.
What we will do is add the remaining ghosts with their specific AI behaviors, including a reverse to the player eating a large pellet.
I also added a simple title screen.</p>

<p>Behold our end goal for today!</p>

<p><img src="/images/PMC06.gif" alt="Running Win32 Application" /></p>

<hr />

<h2 id="goals-for-today">Goals for Today</h2>
<ul>
  <li>Adding a title screen</li>
  <li>Cleanup distance calculation</li>
  <li>Add a new ghost and its assets</li>
  <li>Scatter mode and scatter targets</li>
  <li>AI visualization</li>
  <li>Reversing Decisions</li>
</ul>

<h3 id="assumptions">Assumptions</h3>
<ul>
  <li>You went through the previous post(s)</li>
</ul>

<hr />

<h4 id="github-repohttpsgithubcommanixaistxplat-pmc-tutorial-06"><a href="https://github.com/manixaist/xplat-pmc-tutorial-06">Github repo</a></h4>

<h2 id="adding-a-title-screen">Adding a Title Screen</h2>
<p>This is really setup already, we’ve included a GameState for this that we currently skip over.  Instead of skipping over, now we’re going to render a title screen image.  To proceed into the next state, we’ll wait for some sort of directional input.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fQuit</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">_state</span><span class="p">)</span>
            <span class="p">{</span>
            <span class="k">case</span> <span class="n">GameState</span><span class="p">:</span><span class="o">:</span><span class="n">Title</span><span class="o">:</span>
                <span class="n">Direction</span> <span class="n">inputDirection</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ProcessInput</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inputDirection</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">_state</span> <span class="o">=</span> <span class="n">GameState</span><span class="o">::</span><span class="n">Exiting</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inputDirection</span> <span class="o">!=</span> <span class="n">Direction</span><span class="o">::</span><span class="n">None</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">_state</span> <span class="o">=</span> <span class="n">GameState</span><span class="o">::</span><span class="n">WaitingToStartLevel</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span></code></pre></figure>

<p>Now inside the common Render() method, we differentiate based on state again</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">GameHarness</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">_pSDLRenderer</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="n">GameState</span><span class="o">::</span><span class="n">Title</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_pTitleTexture</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_RenderCopy</span><span class="p">(</span>
                <span class="n">_pSDLRenderer</span><span class="p">,</span>
                <span class="n">_pTitleTexture</span><span class="o">-&gt;</span><span class="n">Ptr</span><span class="p">(),</span>
                <span class="nb">nullptr</span><span class="p">,</span>
                <span class="nb">nullptr</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
	<span class="p">...</span>
	<span class="p">...</span></code></pre></figure>

<h2 id="cleanup-distance-calculation">Cleanup Distance Calculation</h2>
<p>Last time I used pixels for distance.  This works ok for Blinky, and we could make it work for the remaining ghosts, but really we care about cell distance rather than pixel distance.
The logic is fairly straightforward, and I liked a particular Stack Overflow answer, so I modified it below.  In short, it counts the diagonal steps taken until you reach either the row or col you’re aiming for then add the number of straight steps needed to finish the walk.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Modified from StackOverflow answer
</span><span class="kt">double</span> <span class="nf">Distance</span><span class="p">(</span><span class="n">Uint16</span> <span class="n">row1</span><span class="p">,</span> <span class="n">Uint16</span> <span class="n">col1</span><span class="p">,</span> <span class="n">Uint16</span> <span class="n">row2</span><span class="p">,</span> <span class="n">Uint16</span> <span class="n">col2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dr</span> <span class="o">=</span> <span class="n">SDL_abs</span><span class="p">(</span><span class="n">row2</span> <span class="o">-</span> <span class="n">row1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">SDL_abs</span><span class="p">(</span><span class="n">col2</span> <span class="o">-</span> <span class="n">col1</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">SDL_min</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">SDL_max</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">diagonalSteps</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">straightSteps</span> <span class="o">=</span> <span class="n">max</span> <span class="o">-</span> <span class="n">min</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">SDL_sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">diagonalSteps</span> <span class="o">+</span> <span class="n">straightSteps</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="add-a-new-ghost">Add a New Ghost</h2>
<p>In the previous post we added everything we need for new ghosts minus the differentiators. These are</p>

<ul>
  <li>New frames</li>
  <li><a href="http://hackipedia.org/Games/Arcade/Pac-man/pacman,%20dossier.html">Different behavior at intersections</a></li>
  <li>Different scatter targets (next section)</li>
</ul>

<p>Frames are handled during init, so this is just pointing to either a new texture, or a new position on the existing texture.  We will do the latter and keep the sprites on one texture.
Behavior specialization is achieved by implementing the pure virtual MakeBranchDecision() method.
Scatter targets are just another member field we will add and init per ghost.</p>

<h2 id="scatter-mode">Scatter Mode</h2>
<p>When a ghost is not chasing or warping, he’s likely scattering.  In this mode the ghosts move toward their individual scatter targets which are off the maze in the corners (meaning they can never be reached).  Note: We’ve not adding dying for the ghost yet, and the pen state is handled.</p>

<h2 id="ai-visualization">AI Visualization</h2>
<p>In order to see the AI in action I’m adding 2 things.  First, the ability to turn the ghosts on and off.  This way we can see them one at at time and tweak any incorrect behavior.  The only exception to this is Inky, who reguires Blinky in order to make a decision.  He must also be enabled.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// TEMP compile time flags for ghost enabling
</span><span class="cp">#define GHOST_BLINKY
#define GHOST_PINKY
#define GHOST_INKY
#define GHOST_CLYDE
</span>
<span class="c1">// requires Blinky so make sure we enabled it
// will crash otherwise
</span><span class="cp">#ifdef GHOST_INKY
#ifndef GHOST_BLINKY
#define GHOST_BLINKY
#endif
#endif
</span>
<span class="kt">void</span> <span class="n">GameHarness</span><span class="o">::</span><span class="n">InitializeSprites</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// In all cases we create a player
</span>    <span class="n">SDL_assert</span><span class="p">(</span><span class="n">_fInitialized</span><span class="p">);</span>
    <span class="n">InitGameSprite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pPlayer</span><span class="p">,</span> <span class="n">_pSpriteTexture</span><span class="p">,</span> <span class="n">_pMaze</span><span class="p">);</span>

    <span class="c1">// The ghosts are controlled by these flags
</span><span class="cp">#ifdef GHOST_BLINKY
</span>    <span class="n">InitGameSprite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pBlinky</span><span class="p">,</span> <span class="n">_pSpriteTexture</span><span class="p">,</span> <span class="n">_pMaze</span><span class="p">);</span>
    <span class="n">_pGhosts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_pBlinky</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef GHOST_PINKY
</span>    <span class="n">InitGameSprite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pPinky</span><span class="p">,</span> <span class="n">_pSpriteTexture</span><span class="p">,</span> <span class="n">_pMaze</span><span class="p">);</span>
    <span class="n">_pGhosts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_pPinky</span><span class="p">;</span>
<span class="cp">#endif
</span>
    <span class="c1">// Will also enable blinky as he is needed for Inky's
</span>    <span class="c1">// targeting scheme
</span><span class="cp">#ifdef GHOST_INKY
</span>    <span class="n">InitGameSprite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pInky</span><span class="p">,</span> <span class="n">_pSpriteTexture</span><span class="p">,</span> <span class="n">_pMaze</span><span class="p">);</span>
    <span class="n">_pInky</span><span class="o">-&gt;</span><span class="n">SetBlinkyReference</span><span class="p">(</span><span class="n">_pBlinky</span><span class="p">);</span>
    <span class="n">_pGhosts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_pInky</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef GHOST_CLYDE
</span>    <span class="n">InitGameSprite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pClyde</span><span class="p">,</span> <span class="n">_pSpriteTexture</span><span class="p">,</span> <span class="n">_pMaze</span><span class="p">);</span>
    <span class="n">_pGhosts</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">_pClyde</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span></code></pre></figure>

<p>You’ll notice above that I’ve stuck all the ghosts into an array.  Remember that they are all ghosts (as well as sprites) so all common behavior can be invoked through that class interface.</p>

<h3 id="blinky">Blinky</h3>
<p>We did this one last time.  The target is still the player, though now we add the scatter target</p>

<p><img src="/images/blinky_ai.gif" alt="Blinky" /></p>

<h3 id="pinky">Pinky</h3>
<p>Pinky’s target is always 4 spaces ahead of the player.  The exception is when the player is facing up, and that already mentioned famous overflow bug comes into play.  I’ve gone ahead and left that behavior, so the target will be offset up and left in the cases where the player is moving up.</p>

<p><img src="/images/pinky_ai.gif" alt="Pinky" /></p>

<h3 id="inky">Inky</h3>
<p>Inky requires Blinky as mentioned and the reason is, we take a line from 2 spaces ahead of the player and Blinky’s current cell and extend it to twice its length.  The end of that line becomes Inky’s target</p>

<p><img src="/images/inky_ai.gif" alt="Inky" /></p>

<h3 id="clyde">Clyde</h3>
<p>Clyde’s target is the player, but only if 8 tiles or more away, then it becomes its scatter target in the lower left corner.  This means by himself he won’t hit the player unless you let him or get in his way intentionally.</p>

<p>A short aside - SDL does not provide a circle drawing method.  Largely because games just don’t use them, but here visualizing that circle is helpful.</p>

<p>If you remember your unit circle, we can break the X and Y components up into cos(theta) sin(theta) where theta is the angle.</p>

<p><img src="/images/unitcircle.png" alt="UC" /></p>

<p>We don’t want to do those calculations each frame (though likely we could get away with it here), so what we can do is run through the angles we care about from 0 to 360 (or 0 to 2pi) and store the results in arrays.  Then we can loop through the arrays multiplying each value by a scalar (radius) and drawing a dot at each location.</p>

<p>The actual code (look in OnLoading()) iterates over 1440 points on the circle (or 360 * 4, or every .25 degrees).  You can play with the total number if you wish.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ghostIndex</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// Clyde
</span>    <span class="p">{</span>
        <span class="n">SDL_Point</span> <span class="n">clydePoint</span> <span class="o">=</span> <span class="p">{</span> <span class="n">_pGhosts</span><span class="p">[</span><span class="n">ghostIndex</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">X</span><span class="p">(),</span> <span class="n">_pGhosts</span><span class="p">[</span><span class="n">ghostIndex</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">()</span> <span class="p">};</span>
        <span class="n">SDL_Point</span> <span class="n">clydeCircle</span><span class="p">[</span><span class="n">SDL_arraysize</span><span class="p">(</span><span class="n">CosineTable</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="p">};</span>
        <span class="c1">// Draw 'circle' using pre-calculated cos/sin table
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">SDL_arraysize</span><span class="p">(</span><span class="n">CosineTable</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">clydeCircle</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> 
                <span class="n">clydePoint</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">CosineTable</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">TileWidth</span><span class="p">),</span>
                <span class="n">clydePoint</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">SineTable</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">TileHeight</span><span class="p">)</span> 
            <span class="p">};</span>
        <span class="p">}</span>
        <span class="n">SDL_RenderDrawPoints</span><span class="p">(</span><span class="n">_pSDLRenderer</span><span class="p">,</span> <span class="n">clydeCircle</span><span class="p">,</span> <span class="n">SDL_arraysize</span><span class="p">(</span><span class="n">clydeCircle</span><span class="p">));</span>
    <span class="p">}</span></code></pre></figure>

<p><img src="/images/clyde_ai.gif" alt="Clyde" /></p>

<h2 id="reversing-decisions">Reversing Decisions</h2>
<p>When the player eats a large pellet, the ghosts need to update their targets, reverse course and start scattering.  The GameHarness tracks collsions with pellets, so it will have to be responsible for notfiying the ghosts as well.  Because we have them in an array, this iteration is also easy.</p>

<ul>
  <li>Detect the collision</li>
  <li>Notify all ghosts</li>
  <li>Each ghost reverses and updates its targets</li>
</ul>

<p>This is even easier if we start tracking our previous decision rather than throwing it away (deleting it).</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// Detect if the player has entered a pellet tile and remove it, incrementing our counter
// If the pellet is BIG, then trigger the ghost behavior
</span><span class="n">Uint16</span> <span class="n">GameHarness</span><span class="o">::</span><span class="n">HandlePelletCollision</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Uint16</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">SDL_Point</span> <span class="n">playerPoint</span> <span class="o">=</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pPlayer</span><span class="o">-&gt;</span><span class="n">X</span><span class="p">()),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pPlayer</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">())</span> <span class="p">};</span>
    <span class="n">Uint16</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Uint16</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">_pMaze</span><span class="o">-&gt;</span><span class="n">GetTileRowCol</span><span class="p">(</span><span class="n">playerPoint</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_pMaze</span><span class="o">-&gt;</span><span class="n">IsTilePellet</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_pMaze</span><span class="o">-&gt;</span><span class="n">EatPellet</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">ret</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_pMaze</span><span class="o">-&gt;</span><span class="n">IsTilePowerPellet</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">_pMaze</span><span class="o">-&gt;</span><span class="n">EatPellet</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">ret</span><span class="o">++</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SDL_arraysize</span><span class="p">(</span><span class="n">_pGhosts</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pGhosts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_pGhosts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">OnPowerPelletEaten</span><span class="p">(</span><span class="n">_pMaze</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Ghost</span><span class="o">::</span><span class="n">OnPowerPelletEaten</span><span class="p">(</span><span class="n">Maze</span><span class="o">*</span> <span class="n">pMaze</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Called by the GameHarness when the player eats a pellet
</span>    <span class="n">_fScatter</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_scatterTimer</span><span class="p">.</span><span class="n">IsStarted</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">_scatterTimer</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">_scatterTimer</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
        <span class="n">_scatterTimer</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_mode</span> <span class="o">==</span> <span class="n">Mode</span><span class="o">::</span><span class="n">Chase</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Don't do this for other cases like warping
</span>        <span class="c1">// Let the velocity stay managed by those handlers
</span>        <span class="n">ReverseDirection</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">UpdateAnimation</span><span class="p">(</span><span class="n">CurrentDirection</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Ghost</span><span class="o">::</span><span class="n">ReverseDirection</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// this should be safe in all cases
</span>    <span class="n">SetVelocity</span><span class="p">(</span><span class="n">DX</span><span class="p">()</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">DY</span><span class="p">()</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">SafeDelete</span><span class="o">&lt;</span><span class="n">Decision</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pNextDecision</span><span class="p">);</span>
 
    <span class="n">Decision</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">_pCurrentDecision</span><span class="p">;</span>
    <span class="n">Direction</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">Opposite</span><span class="p">(</span><span class="n">_pPrevDecision</span><span class="o">-&gt;</span><span class="n">GetDirection</span><span class="p">());</span>
    <span class="n">_pCurrentDecision</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Decision</span><span class="p">(</span><span class="n">_currentRow</span><span class="p">,</span> <span class="n">_currentCol</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

    <span class="n">SafeDelete</span><span class="o">&lt;</span><span class="n">Decision</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pPrevDecision</span><span class="p">);</span>
    <span class="n">SafeDelete</span><span class="o">&lt;</span><span class="n">Decision</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

<span class="p">}</span></code></pre></figure>

<p>The graphic below outlines the reverse logic for the most complex case we have. Proving this works for the simpler linear case is trivial if you understand this one.</p>

<p><img src="/images/ghostreverse.png" alt="Reverse" /></p>

<p>Here it is in motion…</p>

<p><img src="/images/GhostReverse.gif" alt="Reverse" /></p>

<h2 id="output">Output</h2>
<hr />
<p>win32 (linux looks the same, compile it and see! I checked)</p>

<p><img src="/images/PMC06.gif" alt="Running Win32 Application" /></p>

<hr />

<h3 id="coming-soon">Coming soon</h3>
<p>Player lives and ghost collisions</p>


  </div>

</article>

</section>
<nav class="navbar navbar-default navbar-fixed-bottom">
  <div class="container footer-content">
    <p>2016-09-27 10:47:00 -0700</p>
  </div>
</nav>


  </body>

</html>
